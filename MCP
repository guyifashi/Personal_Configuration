// src/index.ts - å®Œæ•´å·¥ä½œçš„æ™ºèƒ½å¬å†™åŠ©æ‰‹MCPæœåŠ¡å™¨
import { exec } from â€˜child_processâ€™;
import { promisify } from â€˜utilâ€™;
import fetch from â€˜node-fetchâ€™;
import { writeFileSync, unlinkSync, existsSync, mkdirSync } from â€˜fsâ€™;
import { join } from â€˜pathâ€™;

const execAsync = promisify(exec);

async function createServer() {
try {
// åŠ¨æ€å¯¼å…¥MCPæ¨¡å—
const { Server } = await import(â€™@modelcontextprotocol/sdk/server/index.jsâ€™);
const { StdioServerTransport } = await import(â€™@modelcontextprotocol/sdk/server/stdio.jsâ€™);
const { CallToolRequestSchema, ListToolsRequestSchema } = await import(â€™@modelcontextprotocol/sdk/types.jsâ€™);

```
// åˆ›å»ºæœåŠ¡å™¨å®ä¾‹
const server = new Server(
  {
    name: 'dictation-assistant',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// åˆ›å»ºéŸ³é¢‘ç¼“å­˜ç›®å½•
const audioDir = join(process.cwd(), 'audio_cache');
try {
  if (!existsSync(audioDir)) {
    mkdirSync(audioDir, { recursive: true });
    console.error('âœ… éŸ³é¢‘ç¼“å­˜ç›®å½•å·²åˆ›å»º');
  }
} catch (error) {
  console.error('âš ï¸  éŸ³é¢‘ç¼“å­˜ç›®å½•åˆ›å»ºå¤±è´¥ï¼Œå°†è·³è¿‡éŸ³é¢‘ç¼“å­˜åŠŸèƒ½:', error);
}

// åŠ¨æ€å­˜å‚¨ä»æœç´¢ä¸­è·å–çš„æ•™æè¯è¯­
const dynamicTextbookWords = new Map<string, { pinyin: string, words: string[] }>();

// å½“å‰è¯­éŸ³è®¾ç½®
let voiceSettings = {
  service: 'google',
  voice: 'cmn-CN-Wavenet-D',
  speed: 1.0,
  pitch: 0.0,
  pauseDuration: 10 // æ¯ä¸ªç”Ÿå­—åçš„åœé¡¿æ—¶é—´ï¼ˆç§’ï¼‰
};

// ç”ŸæˆéŸ³é¢‘æ–‡ä»¶çš„å“ˆå¸Œåç§°
function getAudioFileName(text: string): string {
  const hash = Buffer.from(text + voiceSettings.voice + voiceSettings.speed + voiceSettings.pitch).toString('base64').replace(/[/+=]/g, '');
  return `${hash}.mp3`;
}

// é¢„ç”Ÿæˆå•ä¸ªéŸ³é¢‘æ–‡ä»¶
async function preGenerateAudio(text: string): Promise<string> {
  const fileName = getAudioFileName(text);
  const filePath = join(audioDir, fileName);
  
  // æ£€æŸ¥ç¼“å­˜
  if (existsSync(filePath)) {
    console.error(`ğŸ“ ä½¿ç”¨ç¼“å­˜éŸ³é¢‘: ${text.substring(0, 20)}...`);
    return filePath;
  }

  try {
    const apiKey = process.env.GOOGLE_TTS_API_KEY;
    
    if (!apiKey || apiKey === 'your_google_api_key_here') {
      throw new Error('Google TTS API Keyæœªé…ç½®');
    }

    console.error(`ğŸµ ç”ŸæˆéŸ³é¢‘: ${text.substring(0, 20)}...`);

    const requestData = {
      input: { text: text },
      voice: {
        languageCode: 'cmn-CN',
        name: voiceSettings.voice,
        ssmlGender: voiceSettings.voice.includes('A') || voiceSettings.voice.includes('D') ? 'FEMALE' : 'MALE'
      },
      audioConfig: {
        audioEncoding: 'MP3',
        speakingRate: voiceSettings.speed,
        pitch: voiceSettings.pitch,
        volumeGainDb: 0.0,
        sampleRateHertz: 24000
      }
    };

    const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestData)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Google TTS APIé”™è¯¯: ${response.status} - ${errorText}`);
    }

    const result = await response.json() as any;
    
    if (result.audioContent) {
      const audioBuffer = Buffer.from(result.audioContent, 'base64');
      writeFileSync(filePath, audioBuffer);
      console.error(`ğŸ’¾ éŸ³é¢‘å·²ä¿å­˜: ${fileName}`);
      return filePath;
    } else {
      throw new Error('Google TTSè¿”å›æ•°æ®æ— æ•ˆ');
    }

  } catch (error) {
    console.error(`ç”ŸæˆéŸ³é¢‘å¤±è´¥: ${error}`);
    throw error;
  }
}

// æ’­æ”¾éŸ³é¢‘æ–‡ä»¶
async function playAudio(filePath: string): Promise<void> {
  try {
    await execAsync(`afplay "${filePath}"`);
  } catch (error) {
    console.error(`æ’­æ”¾éŸ³é¢‘å¤±è´¥: ${error}`);
  }
}

// å»¶è¿Ÿå‡½æ•°
function delay(seconds: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}

// è°ƒç”¨ç«å±±å¼•æ“APIè·å–æ•™ææ ‡å‡†è¯è¯­
async function fetchTextbookWords(grade: string, semester: string, textbook: string, lesson?: number): Promise<Record<string, { pinyin: string, words: string[] }>> {
  try {
    const volcanoApiKey = process.env.VOLCANO_API_KEY;
    const volcanoBaseUrl = process.env.VOLCANO_BASE_URL || 'https://ark.cn-beijing.volces.com/api/v3';
    const volcanoModel = process.env.VOLCANO_MODEL || 'deepseek-r1-250528';
    
    if (!volcanoApiKey || volcanoApiKey === 'your_volcano_api_key_here') {
      console.error('ç«å±±å¼•æ“APIæœªé…ç½®ï¼Œæ— æ³•è·å–æ•™æè¯è¯­');
      return {};
    }

    console.error(`ğŸ” è°ƒç”¨ç«å±±å¼•æ“APIè·å–${textbook}${grade}${semester}${lesson ? `ç¬¬${lesson}è¯¾` : ''}çš„æ ‡å‡†è¯è¯­...`);
    
    // æ„å»ºæŸ¥è¯¢æç¤ºè¯
    let prompt = '';
    if (lesson) {
      prompt = `è¯·æä¾›${textbook}${grade}${semester}ç¬¬${lesson}è¯¾çš„æ‰€æœ‰ç”Ÿå­—ï¼ŒåŒ…æ‹¬æ‹¼éŸ³å’Œä¸‰ä¸ªæ ‡å‡†è¯è¯­ã€‚
```

è¦æ±‚ï¼š

1. è¿”å›JSONæ ¼å¼æ•°æ®
1. æ¯ä¸ªç”Ÿå­—åŒ…å«æ‹¼éŸ³å’Œä¸‰ä¸ªæ•™ææ ‡å‡†è¯è¯­
1. æ ¼å¼å¦‚ä¸‹ï¼š
   {
   â€œç”Ÿå­—â€: {
   â€œpinyinâ€: â€œæ‹¼éŸ³â€,
   â€œwordsâ€: [â€œè¯è¯­1â€, â€œè¯è¯­2â€, â€œè¯è¯­3â€]
   }
   }

è¯·ç¡®ä¿è¯è¯­æ¥è‡ªæ•™ææ ‡å‡†é…å¥—ï¼Œé€‚åˆå°å­¦ç”Ÿå­¦ä¹ ã€‚åªè¿”å›JSONæ•°æ®ï¼Œä¸è¦å…¶ä»–è¯´æ˜æ–‡å­—ã€‚`; } else { prompt = `è¯·æä¾›${textbook}${grade}${semester}çš„æ‰€æœ‰ç”Ÿå­—ï¼ŒåŒ…æ‹¬æ‹¼éŸ³å’Œä¸‰ä¸ªæ ‡å‡†è¯è¯­ã€‚

è¦æ±‚ï¼š

1. è¿”å›JSONæ ¼å¼æ•°æ®
1. æ¯ä¸ªç”Ÿå­—åŒ…å«æ‹¼éŸ³å’Œä¸‰ä¸ªæ•™ææ ‡å‡†è¯è¯­
1. æŒ‰è¯¾æ–‡é¡ºåºæ’åˆ—
1. æ ¼å¼å¦‚ä¸‹ï¼š
   {
   â€œç”Ÿå­—â€: {
   â€œpinyinâ€: â€œæ‹¼éŸ³â€,
   â€œwordsâ€: [â€œè¯è¯­1â€, â€œè¯è¯­2â€, â€œè¯è¯­3â€]
   }
   }

åªè¿”å›JSONæ•°æ®ï¼Œä¸è¦å…¶ä»–è¯´æ˜æ–‡å­—ã€‚`;
}

```
    // è°ƒç”¨ç«å±±å¼•æ“API
    const response = await fetch(`${volcanoBaseUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${volcanoApiKey}`
      },
      body: JSON.stringify({
        model: volcanoModel,
        messages: [
          {
            role: 'system',
            content: 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å­¦è¯­æ–‡æ•™æåŠ©æ‰‹ï¼Œèƒ½å¤Ÿå‡†ç¡®æä¾›æ•™æä¸­çš„ç”Ÿå­—ä¿¡æ¯ã€‚è¯·åªè¿”å›è¦æ±‚çš„JSONæ ¼å¼æ•°æ®ï¼Œä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šè¯´æ˜ã€‚'
          },
          {
            role: 'user',
            content: prompt
          }
        ]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`ç«å±±å¼•æ“APIè°ƒç”¨å¤±è´¥: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const result = await response.json() as any;
    const content = result.choices?.[0]?.message?.content;
    
    if (!content) {
      throw new Error('ç«å±±å¼•æ“APIè¿”å›æ•°æ®æ ¼å¼é”™è¯¯');
    }

    console.error('ğŸ” APIåŸå§‹å“åº”:', content.substring(0, 200) + '...');

    // è§£æJSONå“åº”
    try {
      // æå–JSONéƒ¨åˆ†ï¼ˆå¤„ç†å¯èƒ½çš„markdownæ ¼å¼æˆ–å¤šä½™æ–‡å­—ï¼‰
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('å“åº”ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°æ®');
      }

      const wordsData = JSON.parse(jsonMatch[0]);
      const characterCount = Object.keys(wordsData).length;
      console.error(`âœ… æˆåŠŸè·å–${characterCount}ä¸ªç”Ÿå­—çš„æ ‡å‡†è¯è¯­`);
      
      // éªŒè¯æ•°æ®æ ¼å¼
      for (const [char, data] of Object.entries(wordsData)) {
        if (typeof data !== 'object' || !data.pinyin || !Array.isArray(data.words)) {
          console.error(`âš ï¸  ç”Ÿå­—"${char}"æ•°æ®æ ¼å¼ä¸æ­£ç¡®:`, data);
        }
      }
      
      return wordsData;
      
    } catch (parseError) {
      console.error('è§£æç«å±±å¼•æ“APIå“åº”å¤±è´¥:', parseError);
      console.error('åŸå§‹å“åº”:', content);
      throw new Error(`ç«å±±å¼•æ“APIå“åº”æ ¼å¼æ— æ•ˆ: ${parseError.message}`);
    }

  } catch (error) {
    console.error(`è°ƒç”¨ç«å±±å¼•æ“APIå¤±è´¥: ${error}`);
    return {};
  }
}

// é¢„ç”Ÿæˆæ‰€æœ‰å¬å†™éŸ³é¢‘
async function preGenerateAllDictationAudio(characters: string[]): Promise<Map<string, string>> {
  const audioFiles = new Map<string, string>();
  
  console.error(`ğŸµ å¼€å§‹é¢„ç”Ÿæˆ${characters.length}ä¸ªç”Ÿå­—çš„éŸ³é¢‘æ–‡ä»¶...`);
  
  for (let i = 0; i < characters.length; i++) {
    const character = characters[i];
    const { pinyin, words } = getWordsForCharacter(character);
    
    // æ„å»ºæœ—è¯»æ–‡æœ¬
    const text = `ç¬¬${i + 1}ä¸ªç”Ÿå­—ï¼š${character}ï¼Œæ‹¼éŸ³ï¼š${pinyin}ã€‚è¯è¯­ï¼š${words.join('ï¼Œ')}`;
    
    try {
      const audioFile = await preGenerateAudio(text);
      audioFiles.set(character, audioFile);
      console.error(`âœ… [${i + 1}/${characters.length}] ${character} éŸ³é¢‘å·²ç”Ÿæˆ`);
    } catch (error) {
      console.error(`âŒ [${i + 1}/${characters.length}] ${character} éŸ³é¢‘ç”Ÿæˆå¤±è´¥: ${error}`);
    }
    
    // é¿å…APIé™æµï¼Œç¨å¾®å»¶è¿Ÿ
    if (i < characters.length - 1) {
      await delay(0.2);
    }
  }
  
  console.error(`ğŸ‰ æ‰€æœ‰éŸ³é¢‘é¢„ç”Ÿæˆå®Œæˆï¼`);
  return audioFiles;
}

// è‡ªåŠ¨æ’­æ”¾å¬å†™åºåˆ—
async function playDictationSequence(characters: string[], audioFiles: Map<string, string>, sessionId: string): Promise<void> {
  console.error(`ğŸ”Š å¼€å§‹è‡ªåŠ¨æ’­æ”¾å¬å†™åºåˆ—...`);
  
  for (let i = 0; i < characters.length; i++) {
    const character = characters[i];
    const audioFile = audioFiles.get(character);
    
    if (audioFile && existsSync(audioFile)) {
      console.error(`ğŸ”Š [${i + 1}/${characters.length}] æ’­æ”¾: ${character}`);
      await playAudio(audioFile);
      
      // ä¸æ˜¯æœ€åä¸€ä¸ªå­—ç¬¦æ—¶æ‰åœé¡¿
      if (i < characters.length - 1) {
        console.error(`â±ï¸  ç­‰å¾…${voiceSettings.pauseDuration}ç§’åç»§ç»­...`);
        await delay(voiceSettings.pauseDuration);
      }
    } else {
      console.error(`âŒ [${i + 1}/${characters.length}] ${character} éŸ³é¢‘æ–‡ä»¶ä¸å­˜åœ¨`);
    }
  }
  
  console.error(`ğŸ‰ å¬å†™åºåˆ—æ’­æ”¾å®Œæˆï¼`);
}

// è·å–è¯è¯­
function getWordsForCharacter(character: string): { pinyin: string, words: string[] } {
  return dynamicTextbookWords.get(character) || { 
    pinyin: 'unknown', 
    words: [`${character}å­—`, `å­¦${character}`, `å†™${character}`] 
  };
}

// æ³¨å†Œå·¥å…·åˆ—è¡¨
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'get_lesson_characters',
        description: 'è·å–æŒ‡å®šè¯¾æ–‡çš„ç”Ÿå­—å’Œæ ‡å‡†è¯è¯­',
        inputSchema: {
          type: 'object',
          properties: {
            lesson_number: { type: 'number', description: 'è¯¾æ–‡ç¼–å·ï¼Œå¦‚7' },
            grade: { type: 'string', description: 'å¹´çº§', default: 'ä¸‰å¹´çº§' },
            semester: { type: 'string', description: 'å­¦æœŸ', default: 'ä¸‹å†Œ' },
            textbook: { type: 'string', description: 'æ•™æç‰ˆæœ¬', default: 'éƒ¨ç¼–ç‰ˆ' }
          },
          required: ['lesson_number']
        }
      },
      {
        name: 'search_characters',
        description: 'æœç´¢æŒ‡å®šæ•™æçš„ç”Ÿå­—',
        inputSchema: {
          type: 'object',
          properties: {
            grade: { type: 'string', description: 'å¹´çº§ï¼Œå¦‚"ä¸‰å¹´çº§"' },
            semester: { type: 'string', description: 'å­¦æœŸï¼Œå¦‚"ä¸‹å†Œ"' },
            textbook: { type: 'string', description: 'æ•™æç‰ˆæœ¬ï¼Œå¦‚"éƒ¨ç¼–ç‰ˆ"' }
          },
          required: ['grade', 'semester', 'textbook']
        }
      },
      {
        name: 'start_dictation',
        description: 'å¼€å§‹å¬å†™ä¼šè¯ï¼ˆé¢„ç”ŸæˆéŸ³é¢‘å¹¶è‡ªåŠ¨æ’­æ”¾ï¼‰',
        inputSchema: {
          type: 'object',
          properties: {
            characters: { 
              type: 'array', 
              items: { type: 'string' },
              description: 'è¦å¬å†™çš„ç”Ÿå­—åˆ—è¡¨' 
            },
            with_voice: { type: 'boolean', description: 'æ˜¯å¦å¯ç”¨è¯­éŸ³æœ—è¯»', default: true }
          },
          required: ['characters']
        }
      },
      {
        name: 'speak_character',
        description: 'æœ—è¯»ç”Ÿå­—å’Œè¯è¯­',
        inputSchema: {
          type: 'object',
          properties: {
            character: { type: 'string', description: 'è¦æœ—è¯»çš„ç”Ÿå­—' },
            include_words: { type: 'boolean', description: 'æ˜¯å¦åŒ…å«è¯è¯­', default: true }
          },
          required: ['character']
        }
      },
      {
        name: 'refine_words',
        description: 'è¦æ±‚ç«å±±å¼•æ“é‡æ–°ç”Ÿæˆæˆ–è°ƒæ•´ç”Ÿå­—è¯è¯­',
        inputSchema: {
          type: 'object',
          properties: {
            character: { type: 'string', description: 'è¦è°ƒæ•´è¯è¯­çš„ç”Ÿå­—' },
            requirements: { type: 'string', description: 'è°ƒæ•´è¦æ±‚ï¼Œå¦‚"æ›´ç®€å•çš„è¯è¯­"ã€"æ›´å¸¸ç”¨çš„è¯è¯­"ç­‰' }
          },
          required: ['character', 'requirements']
        }
      },
      {
        name: 'set_voice_settings',
        description: 'è®¾ç½®è¯­éŸ³å‚æ•°',
        inputSchema: {
          type: 'object',
          properties: {
            voice: { type: 'string', description: 'è¯­éŸ³åç§°', default: 'cmn-CN-Wavenet-D' },
            speed: { type: 'number', description: 'è¯­é€Ÿ(0.25-4.0)', default: 1.0 },
            pause_duration: { type: 'number', description: 'ç”Ÿå­—é—´åœé¡¿æ—¶é—´(ç§’)', default: 10 }
          }
        }
      }
    ]
  };
});

// å­˜å‚¨ä¼šè¯æ•°æ®
const sessions = new Map<string, {
  characters: string[],
  currentIndex: number,
  withVoice: boolean,
  startTime: number,
  audioFiles?: Map<string, string>,
  isPlaying?: boolean
}>();

// æ³¨å†Œå·¥å…·è°ƒç”¨å¤„ç†å™¨
server.setRequestHandler(CallToolRequestSchema, async (request: any) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'get_lesson_characters': {
        const { lesson_number, grade = 'ä¸‰å¹´çº§', semester = 'ä¸‹å†Œ', textbook = 'éƒ¨ç¼–ç‰ˆ' } = args;
        console.error(`ğŸ“š è·å–ç¬¬${lesson_number}è¯¾ç”Ÿå­—å’Œè¯è¯­`);
        
        const lessonData = await fetchTextbookWords(grade, semester, textbook, lesson_number);
        
        if (Object.keys(lessonData).length === 0) {
          return {
            content: [{
              type: 'text',
              text: `âŒ æš‚æœªæ‰¾åˆ°ç¬¬${lesson_number}è¯¾çš„ç”Ÿå­—ä¿¡æ¯\n\nå¯èƒ½åŸå› ï¼š\n1. ç«å±±å¼•æ“APIé…ç½®é—®é¢˜\n2. ç½‘ç»œè¿æ¥é—®é¢˜\n3. è¯¾æ–‡ç¼–å·ä¸å­˜åœ¨\n\nè¯·æ£€æŸ¥é…ç½®æˆ–å°è¯•å…¶ä»–è¯¾æ–‡ç¼–å·ã€‚`
            }]
          };
        }

        // æ›´æ–°åŠ¨æ€è¯è¯­åº“
        for (const [char, data] of Object.entries(lessonData)) {
          dynamicTextbookWords.set(char, data);
        }

        const characters = Object.keys(lessonData);
        
        let detailText = `ğŸ“š ${textbook}${grade}${semester}ç¬¬${lesson_number}è¯¾\n\n`;
        detailText += `ğŸ“ æœ¬è¯¾ç”Ÿå­—ï¼ˆ${characters.length}ä¸ªï¼‰ï¼š\n${characters.join('ã€')}\n\n`;
        detailText += `ğŸ“– ç”Ÿå­—è¯¦æƒ…ï¼š\n`;
        
        for (const [char, data] of Object.entries(lessonData)) {
          detailText += `${char}ï¼ˆ${data.pinyin}ï¼‰- ${data.words.join('ã€')}\n`;
        }
        
        detailText += `\nğŸ¤ å½“å‰è¯­éŸ³ï¼šGoogle TTS - ${voiceSettings.voice}`;
        detailText += `\nâ±ï¸ åœé¡¿æ—¶é—´ï¼š${voiceSettings.pauseDuration}ç§’`;
        detailText += `\nğŸ’¡ å¯ä»¥ç›´æ¥å¼€å§‹å¬å†™è¿™äº›ç”Ÿå­—`;

        return {
          content: [{
            type: 'text',
            text: detailText
          }]
        };
      }

      case 'search_characters': {
        const { grade, semester, textbook } = args;
        console.error(`ğŸ” æœç´¢ç”Ÿå­—: ${textbook} ${grade} ${semester}`);
        
        const allData = await fetchTextbookWords(grade, semester, textbook);
        
        if (Object.keys(allData).length === 0) {
          return {
            content: [{
              type: 'text',
              text: `âŒ æš‚æœªæ‰¾åˆ°${textbook}${grade}${semester}çš„ç”Ÿå­—ä¿¡æ¯\n\nè¯·æ£€æŸ¥ç«å±±å¼•æ“APIé…ç½®æˆ–ç½‘ç»œè¿æ¥ã€‚`
            }]
          };
        }

        // æ›´æ–°åŠ¨æ€è¯è¯­åº“
        for (const [char, data] of Object.entries(allData)) {
          dynamicTextbookWords.set(char, data);
        }

        const characters = Object.keys(allData);
        
        return {
          content: [{
            type: 'text',
            text: `âœ… æ‰¾åˆ°${characters.length}ä¸ª${textbook}${grade}${semester}ç”Ÿå­—ï¼š\n\n${characters.join('ã€')}\n\nğŸ“š å·²åŠ è½½æ•™ææ ‡å‡†è¯è¯­\nğŸ”Š æ”¯æŒè¯­éŸ³æœ—è¯»åŠŸèƒ½ï¼\n\nğŸ’¡ å¯ä»¥é€‰æ‹©éƒ¨åˆ†ç”Ÿå­—å¼€å§‹å¬å†™ç»ƒä¹ `
          }]
        };
      }

      case 'start_dictation': {
        const { characters, with_voice = true } = args;
        const sessionId = `session_${Date.now()}`;
        
        if (!with_voice) {
          sessions.set(sessionId, {
            characters,
            currentIndex: 0,
            withVoice: false,
            startTime: Date.now()
          });
          
          return {
            content: [{
              type: 'text',
              text: `ğŸ¯ å¬å†™ä¼šè¯å·²å¼€å§‹ï¼ˆæ— è¯­éŸ³ï¼‰ï¼\n\nğŸ“‹ å¬å†™ç”Ÿå­—ï¼š${characters.join('ã€')}\nğŸ“Š å…± ${characters.length} ä¸ªç”Ÿå­—\nğŸ†” ä¼šè¯IDï¼š${sessionId}`
            }]
          };
        }

        // å¯ç”¨è¯­éŸ³çš„å¬å†™ - é¢„ç”Ÿæˆæ‰€æœ‰éŸ³é¢‘
        try {
          console.error(`ğŸ“ å¼€å§‹å¬å†™: ${characters.length}ä¸ªç”Ÿå­—ï¼ˆå¯ç”¨è¯­éŸ³ï¼‰`);
          
          const responseText = `ğŸ¯ å¬å†™ä¼šè¯å¼€å§‹ï¼\n\nğŸ“‹ å¬å†™ç”Ÿå­—ï¼š${characters.join('ã€')}\nğŸ“Š å…± ${characters.length} ä¸ªç”Ÿå­—\nğŸ†” ä¼šè¯IDï¼š${sessionId}\n\nğŸµ æ­£åœ¨é¢„ç”ŸæˆéŸ³é¢‘æ–‡ä»¶ï¼Œè¯·ç¨å€™...\nâ±ï¸ æ¯ä¸ªç”Ÿå­—åå°†åœé¡¿${voiceSettings.pauseDuration}ç§’\n\nğŸ™ï¸ éŸ³é¢‘ç”Ÿæˆå®Œæˆåå°†è‡ªåŠ¨å¼€å§‹æ’­æ”¾ï¼`;
          
          // å…ˆè¿”å›å“åº”ï¼Œç„¶ååœ¨åå°å¤„ç†
          setImmediate(async () => {
            try {
              // é¢„ç”Ÿæˆæ‰€æœ‰éŸ³é¢‘
              const audioFiles = await preGenerateAllDictationAudio(characters);
              
              // å­˜å‚¨ä¼šè¯ä¿¡æ¯
              sessions.set(sessionId, {
                characters,
                currentIndex: 0,
                withVoice: true,
                startTime: Date.now(),
                audioFiles,
                isPlaying: false
              });
              
              console.error(`âœ… éŸ³é¢‘é¢„ç”Ÿæˆå®Œæˆï¼Œå‡†å¤‡å¼€å§‹è‡ªåŠ¨æ’­æ”¾`);
              
              // å¼€å§‹è‡ªåŠ¨æ’­æ”¾åºåˆ—
              const session = sessions.get(sessionId);
              if (session && !session.isPlaying) {
                session.isPlaying = true;
                await playDictationSequence(characters, audioFiles, sessionId);
                session.isPlaying = false;
              }
              
            } catch (error) {
              console.error(`å¬å†™ä¼šè¯å¤„ç†å¤±è´¥: ${error}`);
            }
          });
          
          return {
            content: [{
              type: 'text',
              text: responseText
            }]
          };
          
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `âŒ å¯åŠ¨å¬å†™å¤±è´¥: ${error}`
            }]
          };
        }
      }

      case 'speak_character': {
        const { character, include_words = true } = args;
        
        const { pinyin, words } = getWordsForCharacter(character);
        
        // æ„å»ºæœ—è¯»æ–‡æœ¬
        let textToSpeak = `ç”Ÿå­—ï¼š${character}ï¼Œæ‹¼éŸ³ï¼š${pinyin}`;
        if (include_words) {
          textToSpeak += `ã€‚è¯è¯­ï¼š${words.join('ï¼Œ')}`;
        }
        
        try {
          const audioFile = await preGenerateAudio(textToSpeak);
          await playAudio(audioFile);
          
          const isFromTextbook = dynamicTextbookWords.has(character);
          
          return {
            content: [{
              type: 'text',
              text: `ğŸ”Š å·²æœ—è¯»ç”Ÿå­—"${character}"ï¼ˆ${pinyin}ï¼‰${include_words ? 'å’Œæ ‡å‡†è¯è¯­' : ''}\n\nğŸ“– è¯è¯­ï¼š${words.join('ã€')}\nğŸ“š æ¥æºï¼š${isFromTextbook ? 'æ•™ææ ‡å‡†' : 'ç³»ç»Ÿç”Ÿæˆ'}\nğŸ¤ è¯­éŸ³ï¼šGoogle TTS`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `âŒ æœ—è¯»å¤±è´¥: ${error}\n\nè¯·æ£€æŸ¥Google TTS APIé…ç½®ã€‚`
            }]
          };
        }
      }

      case 'refine_words': {
        const { character, requirements } = args;
        
        try {
          const volcanoApiKey = process.env.VOLCANO_API_KEY;
          const volcanoBaseUrl = process.env.VOLCANO_BASE_URL || 'https://ark.cn-beijing.volces.com/api/v3';
          const volcanoModel = process.env.VOLCANO_MODEL || 'deepseek-r1-250528';
          
          if (!volcanoApiKey || volcanoApiKey === 'your_volcano_api_key_here') {
            return {
              content: [{
                type: 'text',
                text: `âŒ ç«å±±å¼•æ“APIæœªé…ç½®ï¼Œæ— æ³•è°ƒæ•´è¯è¯­\n\nè¯·åœ¨.envæ–‡ä»¶ä¸­é…ç½®VOLCANO_API_KEY`
              }]
            };
          }

          const prompt = `è¯·ä¸ºç”Ÿå­—"${character}"é‡æ–°ç”Ÿæˆä¸‰ä¸ªè¯è¯­ï¼Œè¦æ±‚ï¼š${requirements}
```

è§„åˆ™ï¼š

1. è¿”å›JSONæ ¼å¼ï¼š{â€œpinyinâ€: â€œæ‹¼éŸ³â€, â€œwordsâ€: [â€œè¯è¯­1â€, â€œè¯è¯­2â€, â€œè¯è¯­3â€]}
1. è¯è¯­è¦é€‚åˆå°å­¦ç”Ÿå­¦ä¹ 
1. è¯è¯­è¦èƒ½æ˜ç¡®ä½“ç°ç”Ÿå­—çš„å«ä¹‰
1. ä¼˜å…ˆé€‰æ‹©æ•™æä¸­çš„æ ‡å‡†è¯è¯­

ç”Ÿå­—ï¼š${character}
è¦æ±‚ï¼š${requirements}

åªè¿”å›JSONæ•°æ®ï¼Œä¸è¦å…¶ä»–è¯´æ˜æ–‡å­—ã€‚`;

```
          console.error(`ğŸ”„ è¦æ±‚ç«å±±å¼•æ“è°ƒæ•´ç”Ÿå­—"${character}"çš„è¯è¯­...`);

          const response = await fetch(`${volcanoBaseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${volcanoApiKey}`
            },
            body: JSON.stringify({
              model: volcanoModel,
              messages: [
                {
                  role: 'system',
                  content: 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å­¦è¯­æ–‡æ•™æåŠ©æ‰‹ï¼Œèƒ½å¤Ÿä¸ºç”Ÿå­—ç”Ÿæˆåˆé€‚çš„è¯è¯­ã€‚è¯·åªè¿”å›è¦æ±‚çš„JSONæ ¼å¼æ•°æ®ã€‚'
                },
                {
                  role: 'user', 
                  content: prompt
                }
              ]
            })
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`ç«å±±å¼•æ“APIè°ƒç”¨å¤±è´¥: ${response.status} ${response.statusText} - ${errorText}`);
          }

          const result = await response.json() as any;
          const content = result.choices?.[0]?.message?.content;
          
          if (!content) {
            throw new Error('ç«å±±å¼•æ“APIè¿”å›æ•°æ®æ ¼å¼é”™è¯¯');
          }

          // è§£æJSONå“åº”
          const jsonMatch = content.match(/\{[\s\S]*?\}/);
          if (!jsonMatch) {
            throw new Error('å“åº”ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°æ®');
          }

          const newData = JSON.parse(jsonMatch[0]);
          
          // éªŒè¯æ•°æ®æ ¼å¼
          if (!newData.pinyin || !Array.isArray(newData.words) || newData.words.length !== 3) {
            throw new Error('è¿”å›çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
          }
          
          // æ›´æ–°åŠ¨æ€è¯è¯­åº“
          dynamicTextbookWords.set(character, newData);
          
          console.error(`âœ… å·²æ›´æ–°ç”Ÿå­—"${character}"çš„è¯è¯­`);

          return {
            content: [{
              type: 'text',
              text: `âœ… å·²æ ¹æ®è¦æ±‚"${requirements}"é‡æ–°ç”Ÿæˆè¯è¯­\n\nğŸ”¤ ç”Ÿå­—ï¼š${character}\nğŸ”¤ æ‹¼éŸ³ï¼š${newData.pinyin}\nğŸ“– æ–°è¯è¯­ï¼š${newData.words.join('ã€')}\n\nğŸ’¡ æ–°è¯è¯­å·²ä¿å­˜ï¼Œåœ¨å¬å†™ä¸­ä¼šä½¿ç”¨æ–°è¯è¯­`
            }]
          };

        } catch (error) {
          console.error(`è°ƒæ•´è¯è¯­å¤±è´¥: ${error}`);
          return {
            content: [{
              type: 'text',
              text: `âŒ è°ƒæ•´è¯è¯­å¤±è´¥: ${error}\n\nè¯·æ£€æŸ¥ç«å±±å¼•æ“APIé…ç½®å’Œç½‘ç»œè¿æ¥`
            }]
          };
        }
      }

      case 'set_voice_settings': {
        const { 
          voice = voiceSettings.voice, 
          speed = voiceSettings.speed,
          pause_duration = voiceSettings.pauseDuration
        } = args || {};
        
        voiceSettings.voice = voice;
        voiceSettings.speed = speed;
        voiceSettings.pauseDuration = pause_duration;

        return {
          content: [{
            type: 'text',
            text: `âœ… è¯­éŸ³è®¾ç½®å·²æ›´æ–°\n\nğŸ—£ï¸ è¯­éŸ³ï¼š${voice}\nâš¡ è¯­é€Ÿï¼š${speed}\nâ±ï¸ åœé¡¿æ—¶é—´ï¼š${pause_duration}ç§’\n\nğŸ’¡ æ–°è®¾ç½®å°†åœ¨ä¸‹æ¬¡å¬å†™æ—¶ç”Ÿæ•ˆ`
```